# Serde Protobuf

`serde-protobuf` is a [`serde`] protobuf data format with first class support for reflection.

This library is meant for academic purposes. It's primary feature is a full writeup of my journey
through rust and creating this library. While correctness is important, do not expect production
level maturity. Speed is important too, but only to the point of quenching curiosity.

## Motivation

There are already protobuf implementations out in the wild, most notably [`prost`], the library
powering [`tonic`]. Why make another?

As many do, to get a better grasp of rust, I felt the need to work on a project. I took personal
interest in [`protobuf`] and [`grpc`]. In particular, I wanted to try making a server that 
supports the [`transcoding`] `google.api.http` annotation.

```protobuf
rpc GetShelf(GetShelfRequest) returns (Shelf) {
  option (google.api.http) = { get: "/v1/shelves/{shelf}" };
  // above will auto-magically transcode a HTTP GET /v1/shelves/{shelf}
  // into a GetShelf(GetShelfRequest) for a gRPC server and also transcode
  // the Shelf response into a JSON object
}

message GetShelfRequest {
  int64 shelf = 1;
}
```

With it gRPC servers could effortlessly add a analog HTTP/JSON interface to their API. This is
especially important for public facing servers since HTTP/JSON is so widespread.

Feeling stoked, I investigated what it would take to support it. What a rabbit hole that turned out
to be! The annotation is a custom option. Custom options are `proto2` extensions that require
working with descriptors. Working with descriptors involves reflection. Not to mention there is a
standard JSON wire format that needs to be supported too. This one little line  ended up traversing
much of the protobuf feature set.

Browsing the rust protobuf ecosystem, I felt that reflection was a critical missing piece of
functionality. In addition to reflection, I felt libraries like prost were missing the distinctive
rust flavor that serde provides. To me, it feels wrong to write a serialization library that does
not support `#[derive(Serialize, Deserialize)]`. And while some libraries did support serde, it
still felt unnatural because each type had their own custom serialization instead of coming up with
a data format.

## Implementation

For the moment, lets forget about serde. How should reflection be implemented?

###  Reflection primer

To a user, reflection is a standardized way to [`describe`] and manipulate any arbitrary object
generated by the protobuf compiler. Any valid `.proto` file can be translated into a
`FileDescriptorProto` protobuf message and back without losing any information. Even comments are
preserved. It is possible to write a common interface that can validate, manipulate, extend, or even
dynamically create any message object from its descriptor. 

Of particular interest is the ability for third parties to extend messages with additional fields.
For example, custom options, like the `google.api.http` annotation, can be created by adding an
extension to `google.protobuf.MessageOptions`. 

For myself, the developer of this library, I would like to to create a protobuf compiler plugin that
is capable of generating these descriptors in rust as well as a way for the generated types to
access their associated descriptor. The generated code can then plug into my reflection library and
its done! Piece of cake right? Right... lets begin.

### Deep dive into `protobuf-go`

Since other protobuf languages have already added reflection, lets use them as an example. After a
little digging, I found [`protobuf-go`], a brand new library implemented in a compiled language with
clear thought put into the reflection interface. It was clear that this interface would be the
standard to base my own interface after.

A brief glance at the source code made it abundantly clear that my life was not going to be easy if
I tried to port the Go implementation to Rust. Lets look at an example:

```protobuf
message Simple {
    bool simple_bool = 1;
}
```

Running the `.proto` through the Go protobuf plugin produces the struct:

```go
type Simple struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SimpleBool bool
}
```

`SimpleBool` is public data, the rest is private reflection state. `state` is interesting in
particular because it contains a single pointer:

```go
type MessageState struct {
	atomicMessageInfo *MessageInfo
}
```

and it happens to always be the first field in the struct. This is not by coincidence. To access the
reflection interface, users call `ProtoReflect`. Here is the implementation:

```go
var file_simple_proto_msgTypes = make([]protoimpl.MessageInfo, 1)

func (x *Simple) ProtoReflect() protoreflect.Message {
	mi := &file_simple_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (ms *messageState) LoadMessageInfo() *MessageInfo {
	return (*MessageInfo)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&ms.atomicMessageInfo))))
}

func (ms *messageState) StoreMessageInfo(mi *MessageInfo) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&ms.atomicMessageInfo)), unsafe.Pointer(mi))
}
```

Without getting into the gory details, this function does two things:

1. It casts `*Simple` to a `*MessageState` which implements the reflective interface `Message`.
1. It stores some static descriptor data into `atomicMessageInfo` if it hasn't been stored already.

With this critical piece of information in mind, lets look at an example of reflection in action:

```go
func TestReflection(t *testing.T) {
	s := proto3.Simple{SimpleBool: true}
	r := s.ProtoReflect()
	v := r.Get(r.Descriptor().Fields().ByName("simple_bool")).Bool()
	if v != s.SimpleBool {
		t.Errorf("field simple_bool = %v, want %v", v, s.SimpleBool)
	}
}
```

Everything up through the call to `ProtoReflect` should be clear, but its only the tip of the
iceberg. We know how the descriptor information, `MessageInfo`, could be accessed through the
`atomicMessageInfo` pointer but, how does a generic type like `MessageState` magically access
something concrete like `s.SimpleBool` by using its descriptor? 

The process is complicated so first lets do a little backtracking. What and where is this
descriptor? Within the generated Go code is an array of byes:

```go
var file_simple_proto_rawDesc = []byte{
	0x0a, 0x0c, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x13,
	//...
}
```

`file_simple_proto_rawDesc` is a serialized `FileDescriptorProto` containing all the static
information for `Simple`. These byes get lazily unmarshalled in various stages as needed during runtime.
For example, calling `Message::Descriptor` initializes less static data than calling `Message::Get`.
In Rust, this is equivalent to wrapping the fields and nested fields in `MessageInfo` with
[`sync::OnceCell<T>`]. 

Speaking of which, lets take a look at the fields in `MessageInfo`. For the purpose of explanation,
some liberties were taken to simplify the code.

```go
type MessageInfo struct {
	Desc         pref.MessageDescriptor
	fields       map[pref.FieldNumber]*fieldInfo
	extensionMap func(pointer) *map[pref.FieldNumber]ExtensionField
	coderFields  map[pref.FieldNumber]*coderFieldInfo
}

type fieldInfo struct {
	fieldDesc pref.FieldDescriptor
	has       func(pointer) bool
	clear     func(pointer)
	get       func(pointer) pref.Value
	set       func(pointer, pref.Value)
}

type coderFieldInfo struct {
	funcs      pointerCoderFuncs
	mi         *MessageInfo      // non-null when field is of type Message
	num        pref.FieldNumber  // unique to each message
	offset     offset            // offset in bytes from beginning of struct
}

type pointerCoderFuncs struct {
	size      func(p pointer, f *coderFieldInfo) int
	marshal   func(b []byte, p pointer, f *coderFieldInfo) ([]byte, error)
	unmarshal func(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo) error
}
```

`MessageInfo` and `fieldInfo` contain their unmarshalled descriptor data, but, the other fields are
more interesting. The function objects take a `pointer` which, as you may have guessed, is
`*MessageState` with or without an offset applied, depending on the function. By indexing some
[`Offset`] into `*MessageState` and casting the data to a [`Value`], the reflective interface is
able to access and modify a concrete message's data, like it did for `Simple` in the test above. To
me this all sounded somewhat nuts, especially for generated code. Go, however, has powerful
reflection capabilities built into the language, so this practice becomes somewhat reasonable.

### But what about Rust? A glance at `Pin`

A Rust analog to the implementation above would have me using `mem::transmute` combined with
something like [`rel-ptr`]. `rel-ptr` looks really cool! But, a brief glance into either of those
two and I am feeling just a smidge uncomfortable. Even with those tool, Rust doesn't have the same
reflective capabilities as Go, so it truly feels like casting into a sea of bytes and praying for
correctness. The point of this project is to learn and Rust seems to be telling me to find another
way. Lets take the hint.

Well, what about a generic field, such as an enum, that holds a reference to the data in the struct.
That generic field could also contain references to generated descriptor data, but lets leave that
out for now. Something like:


```rust
pub enum Value<'a> {
    Bool(&'a bool),
    I32(&'a i32),
}

pub struct Simple<'a> {
    info: Value<'a>,
    pub simple_bool: bool,
}
```

To reflect, just return `info`, a field and type that all generated protobuf messages could have in
common. However, I worry for my users; that lifetime looks contagious. Pointers it is.

```rust
use std::ptr::NonNull;

pub enum Value {
    Bool(NonNull<bool>),
    I32(NonNull<i32>),
}

pub struct Simple {
    info: Value,
    pub simple_bool: bool,
}

impl Simple {
    pub fn new() -> Self {
        let mut s = Simple {
            info: Value::Bool(NonNull::dangling()),
            simple_bool: false,
        };
        s.info = Value::Bool(NonNull::from(&s.simple_bool));
        s
    }
}
```

It's a little clever, but it could work. Well, it doesn't! Check out this test:

```rust
#[test]
fn it_works() {
    let s = Simple::new();
    let v = match s.info {
        Value::Bool(b) => b,
        _ => panic!("Not a Value::Bool"),
    };

    assert_eq!(format!("{:p}", v.as_ptr()), format!("{:p}", &s.simple_bool));
}
```

```
thread 'tests::it_works' panicked at 'assertion failed: `(left == right)`
  left: `"0x7f472cc4e4c0"`,
 right: `"0x7f472cc4e518"`'
```

The object returned from `new` moved! Coming from C++, one of the nice things about Rust is how
natural moving data feels. I almost forgot... until this happened. 

But what now? After some searching, I found something called [`pin`]. The documentation even has an
example for my use case, self-referential structs. I have never seen anything like `Pin` before.
What does it do? Thanks to [`Boats`], [`Jon`], and the [`async-book`], I was finally able to wrap my
head around it and what a wild concept! 

As magical as it is, `Pin` will not solve my problem. Yes, its important to use it when writing
self-referential structs, but it only turns runtime errors, if caught, into compile time errors. It
doesn't help make the move work. It's more of a safety `Pin` (sorry!). 

Ultimately, the real solution is fundamental to any programming language that brings the developer
close to the hardware: use the heap. Heap allocation and `Pin` are a package deal. So much so, that
`Box` has its own [constructor](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.pin)
specifically for pinning objects to the heap. Constructors for self-referential structs are designed
such that heap allocation is forced:

```rust
fn new() -> Pin<Box<Self>>
```

Users interact with heap allocated objects indirectly through pointers and the pointer is free to
move around all it wants. Yes, you can pin objects to the stack, but its incredibly limiting because
stack data gets moved all the time in Rust.

Unfortunately, heap allocating a type like `Simple` feels a little heavy and users would have to
interact with a `Box` instead of the type directly, all for a feature most will never use. Lets
keep searching for alternatives.

### `reflect-heavy` and `reflect-light`

My next big idea is conversion. Something like the [`From`] trait, but fancier.

```rust
pub trait Reflect: Sized {
    fn reflect(self) -> Reflection<Self>;
}

pub struct Reflection<T> {
    message: Message,
    _marker: PhantomData<T>,
}

pub struct Message {
    fields: Vec<Option<Value>>,
}
```

Damn, thats fancy. Whats that [`PhantomData`]? Usually when a type is generic over type
parameter `T`, then the compiler rightfully gets mad if the type doesn't actually use a `T`.
However, there are some use cases where keeping that information around is important. In my case,
its used to track which concrete message to reflect back to.

```rust
impl<T> Reflection<T> {
    pub fn absorb(self) -> Result<T, ReflectionError>
    where
        Message: TryInto<T, Error = ReflectionError>,
    {
        self.message.try_into()
    }
}

impl<T> Reflect for T
where
    T: Into<Message>,
{
    fn reflect(self) -> Reflection<Self> {
        Reflection::new(self)
    }
}
```

Assuming `Simple` implements `Reflect`, converting to and from a `Reflection` looks like:

```rust
let s: Simple = Simple::new();
let r: Reflection<Simple> = s.reflect();
let s: Simple = r.absorb().unwrap();
```

[`prost`]: https://github.com/danburkert/prost
[`tonic`]: https://github.com/hyperium/tonic
[`protobuf`]: https://github.com/protocolbuffers/protobuf
[`grpc`]: https://github.com/grpc/grpc
[`serde`]: https://github.com/serde-rs/serde
[`transcoding`]: https://cloud.google.com/endpoints/docs/grpc/transcoding
[`describe`]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto
[`protobuf-go`]: https://github.com/protocolbuffers/protobuf-go
[`sync::OnceCell<T>`]: https://docs.rs/once_cell
[`Offset`]: https://golang.org/pkg/reflect/#StructField
[`Value`]: https://golang.org/pkg/reflect/#Value
[`rel-ptr`]: https://github.com/RustyYato/rel-ptr
[`pin`]: https://doc.rust-lang.org/std/pin/
[`Boats`]: https://without.boats/
[`Jon`]: https://www.youtube.com/c/JonGjengset
[`async-book`]: https://rust-lang.github.io/async-book/04_pinning/01_chapter.html
[`From`]: https://doc.rust-lang.org/std/convert/trait.From.html
[`PhantomData`]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html
