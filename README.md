# Serde Protobuf

`serde-protobuf` is a [`serde`] protobuf data format with first class support for reflection.

This library is meant for academic purposes. Production level stability is not the primary goal and
neither is speed. Instead you will find a full discourse on my journey with rust and creating this
library.

## Motivation

There are already protobuf implementations out in the wild, most notably [`prost`], used by 
[`tonic`]. Why make another?

While learning rust, I felt the need to work on a project. I found [`protobuf`] and [`grpc`]
interesting, particularly creating a server that can understand either JSON or protobuf via the
[`transcoding`] `google.api.http` annotation. But, What a rabbit hole that turned out to be. The
annotation is a custom option. Custom options are `proto2` extensions that require working with
descriptors. Working with descriptors involves reflection.

Simultaneously, libraries like prost did not feel rusty enough because the generated messages
did not `#[derive(Serialize, Deserialize)]`. And even if they did, each generated type had its own
custom serialization instead of using a data format.

# The Journey

For the moment, lets forget about serde. How should reflection be implemented?

## Reflection primer

To a user, reflection is a standardized way to [`describe`] and manipulate any arbitrary object
generated by the protobuf compiler. Any valid `.proto` file can be translated into a
`FileDescriptorProto` protobuf message and back without losing any information. It is possible to
write a common interface that takes a descriptor and can validate, manipulate, extend, or even
dynamically create any message object. 

Of particular interest is the ability for third parties to extend messages with additional fields.
For example, custom options, like the `google.api.http` annotation, can be created by adding an
extension to `google.protobuf.MessageOptions`. I find this highly desirable since I believe any 
production server should provide a REST analog to their gRCP API. 

For myself, the developer of this library, I would like to to create a protobuf compiler plugin that
is capable of generating these descriptors in Rust as well as a way for the generated types
to access their associated descriptor. The generated code can then be somehow plug into my
reflection library and were done. Piece of cake right?! Lets begin.

## Deep dive into protobuf-go

Since other protobuf languages have already added reflection, lets use them as an example. After a
little digging, I found [`protobuf-go`], a brand new library implemented in a compiled language with
clear thought put into the reflection interface. I decided this was the interface I would like to
model my own interface after.

Digging through the source code, I quickly found out that my life was not going to be easy if I
tried to port the Go implementation to Rust. Lets look at an example:

```protobuf
message Simple {
    bool simple_bool = 1;
}
```

Running the `.proto` through the Go protobuf plugin produces the struct:

```go
type Simple struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SimpleBool bool
}
```

`SimpleBool` is public data, the rest is private reflection state. `state` is interesting in
particular because it contains a single pointer:

```go
type MessageState struct {
	atomicMessageInfo *MessageInfo
}
```

and it happens to always be the first field in the struct. This is not by coincidence. Here is what
happens when we invoke the reflection interface:

```go
var file_simple_proto_msgTypes = make([]protoimpl.MessageInfo, 1)

func (x *Simple) ProtoReflect() protoreflect.Message {
	mi := &file_simple_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (ms *messageState) LoadMessageInfo() *MessageInfo {
	return (*MessageInfo)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&ms.atomicMessageInfo))))
}

func (ms *messageState) StoreMessageInfo(mi *MessageInfo) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&ms.atomicMessageInfo)), unsafe.Pointer(mi))
}
```

Without getting into the gory details, this function does two things:

1. It casts `*Simple` to a `*MessageState` which implements the reflective interface `Message`.
1. It stores some static descriptor data into `atomicMessageInfo` if it hasn't been stored already.

With this critical piece of information in mind, lets take a look at reflection in action.

```go
func TestReflection(t *testing.T) {
	s := proto3.Simple{SimpleBool: true}
	r := s.ProtoReflect()
	v := r.Get(r.Descriptor().Fields().ByName("simple_bool")).Bool()
	if v != s.SimpleBool {
		t.Errorf("field simple_bool = %v, want %v", v, s.SimpleBool)
	}
}
```

We know what the first two lines do, but how does the type `MessageState` lookup `s.SimpleBool`
*through* its descriptor? 

The process is complicated so first lets do a little backtracking. What and where is this
descriptor? Within the generated Go code, its defined as an array of byes:

```go
var file_simple_proto_rawDesc = []byte{
	0x0a, 0x0c, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x13,
	//...
}
```

`file_simple_proto_rawDesc` is a serialized `FileDescriptorProto` which gets lazily unmarshalled in
various stages as needed during runtime. For example, calling `Message::Descriptor` initializes less
static data than calling `Message::Get`. I can guess this is in the name of performance and memory
usage. In rust you can think of `MessageInfo` as a struct containing a bunch of fields wrapped in
[`sync::OnceCell<T>`]. 

Speaking of which, lets take a look
at the fields in `MessageInfo`. Note that some liberties were taken to simplify the code.

```go
type MessageInfo struct {
	Desc         pref.MessageDescriptor
	fields       map[pref.FieldNumber]*fieldInfo
	extensionMap func(pointer) *map[pref.FieldNumber]ExtensionField
	coderFields  map[pref.FieldNumber]*coderFieldInfo
}

type fieldInfo struct {
	fieldDesc pref.FieldDescriptor

	has        func(pointer) bool
	clear      func(pointer)
	get        func(pointer) pref.Value
	set        func(pointer, pref.Value)
	mutable    func(pointer) pref.Value
	newMessage func() pref.Message
	newField   func() pref.Value
}

type coderFieldInfo struct {
	funcs      pointerCoderFuncs // fast-path per-field functions
	mi         *MessageInfo      // field's message, if field is a message
	num        pref.FieldNumber  // field number
	offset     offset            // struct field offset
	wiretag    uint64            // field tag (number + wire type)
	tagsize    int               // size of the varint-encoded tag
	isRequired bool              // true if field is required
}

type pointerCoderFuncs struct {
	size      func(p pointer, f *coderFieldInfo) int
	marshal   func(b []byte, p pointer, f *coderFieldInfo) ([]byte, error)
	unmarshal func(b []byte, p pointer, wtyp protowire.Type, f *coderFieldInfo) error
	merge     func(dst, src pointer, f *coderFieldInfo)
}
```

`Desc` is equivalent to calling `Message::Descriptor` and contains unmarshalled descriptor data for
the message. The other fields are more interesting. They all involve function objects that take a
`pointer` which is either `*MessageState` and an offset is applied in the function or its
`*MessageState` with an offset already applied. By indexing some known offset into `*MessageState`,
the reflective interface is able to access and modify a concrete object's, like `Simple`, data or
even extend an objects data with more fields.

In other words, its all one big `mem::transmute` with 


[`prost`]: https://github.com/danburkert/prost
[`tonic`]: https://github.com/hyperium/tonic
[`protobuf`]: https://github.com/protocolbuffers/protobuf
[`grpc`]: https://github.com/grpc/grpc
[`serde`]: https://github.com/serde-rs/serde
[`transcoding`]: https://cloud.google.com/endpoints/docs/grpc/transcoding
[`describe`]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto
[`protobuf-go`]: https://github.com/protocolbuffers/protobuf-go
[`sync::OnceCell<T>`]: https://docs.rs/once_cell
